// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: success_dungeon_stage.proto

#ifndef PROTOBUF_success_5fdungeon_5fstage_2eproto__INCLUDED
#define PROTOBUF_success_5fdungeon_5fstage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "msg_id.pb.h"
#include "msg_status_code.pb.h"
#include "role_dungeon_reward.pb.h"
#include "gamble_card.pb.h"
#include "role_gamble_card_reward.pb.h"
#include "role_bag_goods.pb.h"
// @@protoc_insertion_point(includes)

namespace sanguo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_success_5fdungeon_5fstage_2eproto();
void protobuf_AssignDesc_success_5fdungeon_5fstage_2eproto();
void protobuf_ShutdownFile_success_5fdungeon_5fstage_2eproto();

class SuccessDungeonStageRequest;
class SuccessDungeonStageResponse;

// ===================================================================

class SuccessDungeonStageRequest : public ::google::protobuf::MessageLite {
 public:
  SuccessDungeonStageRequest();
  virtual ~SuccessDungeonStageRequest();

  SuccessDungeonStageRequest(const SuccessDungeonStageRequest& from);

  inline SuccessDungeonStageRequest& operator=(const SuccessDungeonStageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const SuccessDungeonStageRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SuccessDungeonStageRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SuccessDungeonStageRequest* other);

  // implements Message ----------------------------------------------

  SuccessDungeonStageRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SuccessDungeonStageRequest& from);
  void MergeFrom(const SuccessDungeonStageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sanguo.MsgID msgID = 1;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 1;
  inline ::sanguo::MsgID msgid() const;
  inline void set_msgid(::sanguo::MsgID value);

  // required uint32 stageId = 2;
  inline bool has_stageid() const;
  inline void clear_stageid();
  static const int kStageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 stageid() const;
  inline void set_stageid(::google::protobuf::uint32 value);

  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 clearTime = 4;
  inline bool has_cleartime() const;
  inline void clear_cleartime();
  static const int kClearTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 cleartime() const;
  inline void set_cleartime(::google::protobuf::uint32 value);

  // required uint32 maxBatter = 5;
  inline bool has_maxbatter() const;
  inline void clear_maxbatter();
  static const int kMaxBatterFieldNumber = 5;
  inline ::google::protobuf::uint32 maxbatter() const;
  inline void set_maxbatter(::google::protobuf::uint32 value);

  // required float loseHP = 6;
  inline bool has_losehp() const;
  inline void clear_losehp();
  static const int kLoseHPFieldNumber = 6;
  inline float losehp() const;
  inline void set_losehp(float value);

  // required uint32 reviveTimes = 7;
  inline bool has_revivetimes() const;
  inline void clear_revivetimes();
  static const int kReviveTimesFieldNumber = 7;
  inline ::google::protobuf::uint32 revivetimes() const;
  inline void set_revivetimes(::google::protobuf::uint32 value);

  // required uint32 killEnemyCount = 8;
  inline bool has_killenemycount() const;
  inline void clear_killenemycount();
  static const int kKillEnemyCountFieldNumber = 8;
  inline ::google::protobuf::uint32 killenemycount() const;
  inline void set_killenemycount(::google::protobuf::uint32 value);

  // required uint32 pickCopper = 9;
  inline bool has_pickcopper() const;
  inline void clear_pickcopper();
  static const int kPickCopperFieldNumber = 9;
  inline ::google::protobuf::uint32 pickcopper() const;
  inline void set_pickcopper(::google::protobuf::uint32 value);

  // required uint32 pickHonour = 10;
  inline bool has_pickhonour() const;
  inline void clear_pickhonour();
  static const int kPickHonourFieldNumber = 10;
  inline ::google::protobuf::uint32 pickhonour() const;
  inline void set_pickhonour(::google::protobuf::uint32 value);

  // required uint32 pickGold = 11;
  inline bool has_pickgold() const;
  inline void clear_pickgold();
  static const int kPickGoldFieldNumber = 11;
  inline ::google::protobuf::uint32 pickgold() const;
  inline void set_pickgold(::google::protobuf::uint32 value);

  // repeated uint32 rewardGoodsIds = 12;
  inline int rewardgoodsids_size() const;
  inline void clear_rewardgoodsids();
  static const int kRewardGoodsIdsFieldNumber = 12;
  inline ::google::protobuf::uint32 rewardgoodsids(int index) const;
  inline void set_rewardgoodsids(int index, ::google::protobuf::uint32 value);
  inline void add_rewardgoodsids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rewardgoodsids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rewardgoodsids();

  // @@protoc_insertion_point(class_scope:sanguo.SuccessDungeonStageRequest)
 private:
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_stageid();
  inline void clear_has_stageid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cleartime();
  inline void clear_has_cleartime();
  inline void set_has_maxbatter();
  inline void clear_has_maxbatter();
  inline void set_has_losehp();
  inline void clear_has_losehp();
  inline void set_has_revivetimes();
  inline void clear_has_revivetimes();
  inline void set_has_killenemycount();
  inline void clear_has_killenemycount();
  inline void set_has_pickcopper();
  inline void clear_has_pickcopper();
  inline void set_has_pickhonour();
  inline void clear_has_pickhonour();
  inline void set_has_pickgold();
  inline void clear_has_pickgold();

  int msgid_;
  ::google::protobuf::uint32 stageid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 cleartime_;
  ::google::protobuf::uint32 maxbatter_;
  float losehp_;
  ::google::protobuf::uint32 revivetimes_;
  ::google::protobuf::uint32 killenemycount_;
  ::google::protobuf::uint32 pickcopper_;
  ::google::protobuf::uint32 pickhonour_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rewardgoodsids_;
  ::google::protobuf::uint32 pickgold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_success_5fdungeon_5fstage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_success_5fdungeon_5fstage_2eproto();
  #endif
  friend void protobuf_AssignDesc_success_5fdungeon_5fstage_2eproto();
  friend void protobuf_ShutdownFile_success_5fdungeon_5fstage_2eproto();

  void InitAsDefaultInstance();
  static SuccessDungeonStageRequest* default_instance_;
};
// -------------------------------------------------------------------

class SuccessDungeonStageResponse : public ::google::protobuf::MessageLite {
 public:
  SuccessDungeonStageResponse();
  virtual ~SuccessDungeonStageResponse();

  SuccessDungeonStageResponse(const SuccessDungeonStageResponse& from);

  inline SuccessDungeonStageResponse& operator=(const SuccessDungeonStageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const SuccessDungeonStageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SuccessDungeonStageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SuccessDungeonStageResponse* other);

  // implements Message ----------------------------------------------

  SuccessDungeonStageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SuccessDungeonStageResponse& from);
  void MergeFrom(const SuccessDungeonStageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sanguo.MsgID msgID = 1;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 1;
  inline ::sanguo::MsgID msgid() const;
  inline void set_msgid(::sanguo::MsgID value);

  // required .sanguo.StatusCode status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::sanguo::StatusCode status() const;
  inline void set_status(::sanguo::StatusCode value);

  // optional uint32 roleRemainPower = 3;
  inline bool has_roleremainpower() const;
  inline void clear_roleremainpower();
  static const int kRoleRemainPowerFieldNumber = 3;
  inline ::google::protobuf::uint32 roleremainpower() const;
  inline void set_roleremainpower(::google::protobuf::uint32 value);

  // optional .sanguo.MsgDungeonReward dungeonReward = 4;
  inline bool has_dungeonreward() const;
  inline void clear_dungeonreward();
  static const int kDungeonRewardFieldNumber = 4;
  inline const ::sanguo::MsgDungeonReward& dungeonreward() const;
  inline ::sanguo::MsgDungeonReward* mutable_dungeonreward();
  inline ::sanguo::MsgDungeonReward* release_dungeonreward();
  inline void set_allocated_dungeonreward(::sanguo::MsgDungeonReward* dungeonreward);

  // optional .sanguo.MsgGambleCardReward gambleReward = 5;
  inline bool has_gamblereward() const;
  inline void clear_gamblereward();
  static const int kGambleRewardFieldNumber = 5;
  inline const ::sanguo::MsgGambleCardReward& gamblereward() const;
  inline ::sanguo::MsgGambleCardReward* mutable_gamblereward();
  inline ::sanguo::MsgGambleCardReward* release_gamblereward();
  inline void set_allocated_gamblereward(::sanguo::MsgGambleCardReward* gamblereward);

  // repeated .sanguo.MsgGambleCardItem gambleCards = 6;
  inline int gamblecards_size() const;
  inline void clear_gamblecards();
  static const int kGambleCardsFieldNumber = 6;
  inline const ::sanguo::MsgGambleCardItem& gamblecards(int index) const;
  inline ::sanguo::MsgGambleCardItem* mutable_gamblecards(int index);
  inline ::sanguo::MsgGambleCardItem* add_gamblecards();
  inline const ::google::protobuf::RepeatedPtrField< ::sanguo::MsgGambleCardItem >&
      gamblecards() const;
  inline ::google::protobuf::RepeatedPtrField< ::sanguo::MsgGambleCardItem >*
      mutable_gamblecards();

  // repeated .sanguo.MsgRoleBagGoods randomDropRewards = 7;
  inline int randomdroprewards_size() const;
  inline void clear_randomdroprewards();
  static const int kRandomDropRewardsFieldNumber = 7;
  inline const ::sanguo::MsgRoleBagGoods& randomdroprewards(int index) const;
  inline ::sanguo::MsgRoleBagGoods* mutable_randomdroprewards(int index);
  inline ::sanguo::MsgRoleBagGoods* add_randomdroprewards();
  inline const ::google::protobuf::RepeatedPtrField< ::sanguo::MsgRoleBagGoods >&
      randomdroprewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::sanguo::MsgRoleBagGoods >*
      mutable_randomdroprewards();

  // @@protoc_insertion_point(class_scope:sanguo.SuccessDungeonStageResponse)
 private:
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_roleremainpower();
  inline void clear_has_roleremainpower();
  inline void set_has_dungeonreward();
  inline void clear_has_dungeonreward();
  inline void set_has_gamblereward();
  inline void clear_has_gamblereward();

  int msgid_;
  int status_;
  ::sanguo::MsgDungeonReward* dungeonreward_;
  ::sanguo::MsgGambleCardReward* gamblereward_;
  ::google::protobuf::RepeatedPtrField< ::sanguo::MsgGambleCardItem > gamblecards_;
  ::google::protobuf::RepeatedPtrField< ::sanguo::MsgRoleBagGoods > randomdroprewards_;
  ::google::protobuf::uint32 roleremainpower_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_success_5fdungeon_5fstage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_success_5fdungeon_5fstage_2eproto();
  #endif
  friend void protobuf_AssignDesc_success_5fdungeon_5fstage_2eproto();
  friend void protobuf_ShutdownFile_success_5fdungeon_5fstage_2eproto();

  void InitAsDefaultInstance();
  static SuccessDungeonStageResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// SuccessDungeonStageRequest

// required .sanguo.MsgID msgID = 1;
inline bool SuccessDungeonStageRequest::has_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SuccessDungeonStageRequest::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SuccessDungeonStageRequest::clear_msgid() {
  msgid_ = 1;
  clear_has_msgid();
}
inline ::sanguo::MsgID SuccessDungeonStageRequest::msgid() const {
  return static_cast< ::sanguo::MsgID >(msgid_);
}
inline void SuccessDungeonStageRequest::set_msgid(::sanguo::MsgID value) {
  assert(::sanguo::MsgID_IsValid(value));
  set_has_msgid();
  msgid_ = value;
}

// required uint32 stageId = 2;
inline bool SuccessDungeonStageRequest::has_stageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_stageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SuccessDungeonStageRequest::clear_has_stageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SuccessDungeonStageRequest::clear_stageid() {
  stageid_ = 0u;
  clear_has_stageid();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::stageid() const {
  return stageid_;
}
inline void SuccessDungeonStageRequest::set_stageid(::google::protobuf::uint32 value) {
  set_has_stageid();
  stageid_ = value;
}

// required uint32 type = 3;
inline bool SuccessDungeonStageRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SuccessDungeonStageRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SuccessDungeonStageRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::type() const {
  return type_;
}
inline void SuccessDungeonStageRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 clearTime = 4;
inline bool SuccessDungeonStageRequest::has_cleartime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_cleartime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SuccessDungeonStageRequest::clear_has_cleartime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SuccessDungeonStageRequest::clear_cleartime() {
  cleartime_ = 0u;
  clear_has_cleartime();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::cleartime() const {
  return cleartime_;
}
inline void SuccessDungeonStageRequest::set_cleartime(::google::protobuf::uint32 value) {
  set_has_cleartime();
  cleartime_ = value;
}

// required uint32 maxBatter = 5;
inline bool SuccessDungeonStageRequest::has_maxbatter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_maxbatter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SuccessDungeonStageRequest::clear_has_maxbatter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SuccessDungeonStageRequest::clear_maxbatter() {
  maxbatter_ = 0u;
  clear_has_maxbatter();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::maxbatter() const {
  return maxbatter_;
}
inline void SuccessDungeonStageRequest::set_maxbatter(::google::protobuf::uint32 value) {
  set_has_maxbatter();
  maxbatter_ = value;
}

// required float loseHP = 6;
inline bool SuccessDungeonStageRequest::has_losehp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_losehp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SuccessDungeonStageRequest::clear_has_losehp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SuccessDungeonStageRequest::clear_losehp() {
  losehp_ = 0;
  clear_has_losehp();
}
inline float SuccessDungeonStageRequest::losehp() const {
  return losehp_;
}
inline void SuccessDungeonStageRequest::set_losehp(float value) {
  set_has_losehp();
  losehp_ = value;
}

// required uint32 reviveTimes = 7;
inline bool SuccessDungeonStageRequest::has_revivetimes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_revivetimes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SuccessDungeonStageRequest::clear_has_revivetimes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SuccessDungeonStageRequest::clear_revivetimes() {
  revivetimes_ = 0u;
  clear_has_revivetimes();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::revivetimes() const {
  return revivetimes_;
}
inline void SuccessDungeonStageRequest::set_revivetimes(::google::protobuf::uint32 value) {
  set_has_revivetimes();
  revivetimes_ = value;
}

// required uint32 killEnemyCount = 8;
inline bool SuccessDungeonStageRequest::has_killenemycount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_killenemycount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SuccessDungeonStageRequest::clear_has_killenemycount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SuccessDungeonStageRequest::clear_killenemycount() {
  killenemycount_ = 0u;
  clear_has_killenemycount();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::killenemycount() const {
  return killenemycount_;
}
inline void SuccessDungeonStageRequest::set_killenemycount(::google::protobuf::uint32 value) {
  set_has_killenemycount();
  killenemycount_ = value;
}

// required uint32 pickCopper = 9;
inline bool SuccessDungeonStageRequest::has_pickcopper() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_pickcopper() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SuccessDungeonStageRequest::clear_has_pickcopper() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SuccessDungeonStageRequest::clear_pickcopper() {
  pickcopper_ = 0u;
  clear_has_pickcopper();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::pickcopper() const {
  return pickcopper_;
}
inline void SuccessDungeonStageRequest::set_pickcopper(::google::protobuf::uint32 value) {
  set_has_pickcopper();
  pickcopper_ = value;
}

// required uint32 pickHonour = 10;
inline bool SuccessDungeonStageRequest::has_pickhonour() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_pickhonour() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SuccessDungeonStageRequest::clear_has_pickhonour() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SuccessDungeonStageRequest::clear_pickhonour() {
  pickhonour_ = 0u;
  clear_has_pickhonour();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::pickhonour() const {
  return pickhonour_;
}
inline void SuccessDungeonStageRequest::set_pickhonour(::google::protobuf::uint32 value) {
  set_has_pickhonour();
  pickhonour_ = value;
}

// required uint32 pickGold = 11;
inline bool SuccessDungeonStageRequest::has_pickgold() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SuccessDungeonStageRequest::set_has_pickgold() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SuccessDungeonStageRequest::clear_has_pickgold() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SuccessDungeonStageRequest::clear_pickgold() {
  pickgold_ = 0u;
  clear_has_pickgold();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::pickgold() const {
  return pickgold_;
}
inline void SuccessDungeonStageRequest::set_pickgold(::google::protobuf::uint32 value) {
  set_has_pickgold();
  pickgold_ = value;
}

// repeated uint32 rewardGoodsIds = 12;
inline int SuccessDungeonStageRequest::rewardgoodsids_size() const {
  return rewardgoodsids_.size();
}
inline void SuccessDungeonStageRequest::clear_rewardgoodsids() {
  rewardgoodsids_.Clear();
}
inline ::google::protobuf::uint32 SuccessDungeonStageRequest::rewardgoodsids(int index) const {
  return rewardgoodsids_.Get(index);
}
inline void SuccessDungeonStageRequest::set_rewardgoodsids(int index, ::google::protobuf::uint32 value) {
  rewardgoodsids_.Set(index, value);
}
inline void SuccessDungeonStageRequest::add_rewardgoodsids(::google::protobuf::uint32 value) {
  rewardgoodsids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SuccessDungeonStageRequest::rewardgoodsids() const {
  return rewardgoodsids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SuccessDungeonStageRequest::mutable_rewardgoodsids() {
  return &rewardgoodsids_;
}

// -------------------------------------------------------------------

// SuccessDungeonStageResponse

// required .sanguo.MsgID msgID = 1;
inline bool SuccessDungeonStageResponse::has_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuccessDungeonStageResponse::set_has_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SuccessDungeonStageResponse::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SuccessDungeonStageResponse::clear_msgid() {
  msgid_ = 1;
  clear_has_msgid();
}
inline ::sanguo::MsgID SuccessDungeonStageResponse::msgid() const {
  return static_cast< ::sanguo::MsgID >(msgid_);
}
inline void SuccessDungeonStageResponse::set_msgid(::sanguo::MsgID value) {
  assert(::sanguo::MsgID_IsValid(value));
  set_has_msgid();
  msgid_ = value;
}

// required .sanguo.StatusCode status = 2;
inline bool SuccessDungeonStageResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuccessDungeonStageResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SuccessDungeonStageResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SuccessDungeonStageResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::sanguo::StatusCode SuccessDungeonStageResponse::status() const {
  return static_cast< ::sanguo::StatusCode >(status_);
}
inline void SuccessDungeonStageResponse::set_status(::sanguo::StatusCode value) {
  assert(::sanguo::StatusCode_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional uint32 roleRemainPower = 3;
inline bool SuccessDungeonStageResponse::has_roleremainpower() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SuccessDungeonStageResponse::set_has_roleremainpower() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SuccessDungeonStageResponse::clear_has_roleremainpower() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SuccessDungeonStageResponse::clear_roleremainpower() {
  roleremainpower_ = 0u;
  clear_has_roleremainpower();
}
inline ::google::protobuf::uint32 SuccessDungeonStageResponse::roleremainpower() const {
  return roleremainpower_;
}
inline void SuccessDungeonStageResponse::set_roleremainpower(::google::protobuf::uint32 value) {
  set_has_roleremainpower();
  roleremainpower_ = value;
}

// optional .sanguo.MsgDungeonReward dungeonReward = 4;
inline bool SuccessDungeonStageResponse::has_dungeonreward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SuccessDungeonStageResponse::set_has_dungeonreward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SuccessDungeonStageResponse::clear_has_dungeonreward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SuccessDungeonStageResponse::clear_dungeonreward() {
  if (dungeonreward_ != NULL) dungeonreward_->::sanguo::MsgDungeonReward::Clear();
  clear_has_dungeonreward();
}
inline const ::sanguo::MsgDungeonReward& SuccessDungeonStageResponse::dungeonreward() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dungeonreward_ != NULL ? *dungeonreward_ : *default_instance().dungeonreward_;
#else
  return dungeonreward_ != NULL ? *dungeonreward_ : *default_instance_->dungeonreward_;
#endif
}
inline ::sanguo::MsgDungeonReward* SuccessDungeonStageResponse::mutable_dungeonreward() {
  set_has_dungeonreward();
  if (dungeonreward_ == NULL) dungeonreward_ = new ::sanguo::MsgDungeonReward;
  return dungeonreward_;
}
inline ::sanguo::MsgDungeonReward* SuccessDungeonStageResponse::release_dungeonreward() {
  clear_has_dungeonreward();
  ::sanguo::MsgDungeonReward* temp = dungeonreward_;
  dungeonreward_ = NULL;
  return temp;
}
inline void SuccessDungeonStageResponse::set_allocated_dungeonreward(::sanguo::MsgDungeonReward* dungeonreward) {
  delete dungeonreward_;
  dungeonreward_ = dungeonreward;
  if (dungeonreward) {
    set_has_dungeonreward();
  } else {
    clear_has_dungeonreward();
  }
}

// optional .sanguo.MsgGambleCardReward gambleReward = 5;
inline bool SuccessDungeonStageResponse::has_gamblereward() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SuccessDungeonStageResponse::set_has_gamblereward() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SuccessDungeonStageResponse::clear_has_gamblereward() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SuccessDungeonStageResponse::clear_gamblereward() {
  if (gamblereward_ != NULL) gamblereward_->::sanguo::MsgGambleCardReward::Clear();
  clear_has_gamblereward();
}
inline const ::sanguo::MsgGambleCardReward& SuccessDungeonStageResponse::gamblereward() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamblereward_ != NULL ? *gamblereward_ : *default_instance().gamblereward_;
#else
  return gamblereward_ != NULL ? *gamblereward_ : *default_instance_->gamblereward_;
#endif
}
inline ::sanguo::MsgGambleCardReward* SuccessDungeonStageResponse::mutable_gamblereward() {
  set_has_gamblereward();
  if (gamblereward_ == NULL) gamblereward_ = new ::sanguo::MsgGambleCardReward;
  return gamblereward_;
}
inline ::sanguo::MsgGambleCardReward* SuccessDungeonStageResponse::release_gamblereward() {
  clear_has_gamblereward();
  ::sanguo::MsgGambleCardReward* temp = gamblereward_;
  gamblereward_ = NULL;
  return temp;
}
inline void SuccessDungeonStageResponse::set_allocated_gamblereward(::sanguo::MsgGambleCardReward* gamblereward) {
  delete gamblereward_;
  gamblereward_ = gamblereward;
  if (gamblereward) {
    set_has_gamblereward();
  } else {
    clear_has_gamblereward();
  }
}

// repeated .sanguo.MsgGambleCardItem gambleCards = 6;
inline int SuccessDungeonStageResponse::gamblecards_size() const {
  return gamblecards_.size();
}
inline void SuccessDungeonStageResponse::clear_gamblecards() {
  gamblecards_.Clear();
}
inline const ::sanguo::MsgGambleCardItem& SuccessDungeonStageResponse::gamblecards(int index) const {
  return gamblecards_.Get(index);
}
inline ::sanguo::MsgGambleCardItem* SuccessDungeonStageResponse::mutable_gamblecards(int index) {
  return gamblecards_.Mutable(index);
}
inline ::sanguo::MsgGambleCardItem* SuccessDungeonStageResponse::add_gamblecards() {
  return gamblecards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sanguo::MsgGambleCardItem >&
SuccessDungeonStageResponse::gamblecards() const {
  return gamblecards_;
}
inline ::google::protobuf::RepeatedPtrField< ::sanguo::MsgGambleCardItem >*
SuccessDungeonStageResponse::mutable_gamblecards() {
  return &gamblecards_;
}

// repeated .sanguo.MsgRoleBagGoods randomDropRewards = 7;
inline int SuccessDungeonStageResponse::randomdroprewards_size() const {
  return randomdroprewards_.size();
}
inline void SuccessDungeonStageResponse::clear_randomdroprewards() {
  randomdroprewards_.Clear();
}
inline const ::sanguo::MsgRoleBagGoods& SuccessDungeonStageResponse::randomdroprewards(int index) const {
  return randomdroprewards_.Get(index);
}
inline ::sanguo::MsgRoleBagGoods* SuccessDungeonStageResponse::mutable_randomdroprewards(int index) {
  return randomdroprewards_.Mutable(index);
}
inline ::sanguo::MsgRoleBagGoods* SuccessDungeonStageResponse::add_randomdroprewards() {
  return randomdroprewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sanguo::MsgRoleBagGoods >&
SuccessDungeonStageResponse::randomdroprewards() const {
  return randomdroprewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::sanguo::MsgRoleBagGoods >*
SuccessDungeonStageResponse::mutable_randomdroprewards() {
  return &randomdroprewards_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sanguo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_success_5fdungeon_5fstage_2eproto__INCLUDED
